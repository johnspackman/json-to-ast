{"version":3,"sources":["tokenize.js"],"names":["tokenTypes","LEFT_BRACE","RIGHT_BRACE","LEFT_BRACKET","RIGHT_BRACKET","COLON","COMMA","STRING","NUMBER","TRUE","FALSE","NULL","COMMENT","WHITESPACE","punctuatorTokensMap","keywordTokensMap","type","value","stringStates","_START_","START_QUOTE_OR_CHAR","ESCAPE","escapes","numberStates","MINUS","ZERO","DIGIT","POINT","DIGIT_FRACTION","EXP","EXP_DIGIT_OR_SIGN","isDigit1to9","char","isDigit","isHex","isExp","parseWhitespace","input","index","line","column","charAt","length","parseComment","str","substring","startIndex","parseChar","parseKeyword","name","hasOwnProperty","substr","parseString","settings","buffer","state","result","verbose","rawValue","i","curChar","parseNumber","passedValueIndex","iterator","parseFloat","Tokenizer","tokens","tokenIndex","Error","next","returnWhitespace","token","args","matched","loc","source","push","cannotTokenizeSymbol"],"mappings":"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","file":"tokenize.js","sourcesContent":["import location from './location';\nimport error from './error';\nimport tokenizeErrorTypes from './tokenizeErrorTypes';\n\nexport const tokenTypes = {\n\tLEFT_BRACE: 0,\t\t// {\n\tRIGHT_BRACE: 1,\t\t// }\n\tLEFT_BRACKET: 2,\t// [\n\tRIGHT_BRACKET: 3,\t// ]\n\tCOLON: 4,\t\t\t// :\n\tCOMMA: 5,\t\t\t// ,\n\tSTRING: 6,\t\t\t//\n\tNUMBER: 7,\t\t\t//\n\tTRUE: 8,\t\t\t// true\n\tFALSE: 9,\t\t\t// false\n\tNULL: 10,\t\t\t// null\n\tCOMMENT: 11,\n\tWHITESPACE: 12\n};\n\nconst punctuatorTokensMap = { // Lexeme: Token\n\t'{': tokenTypes.LEFT_BRACE,\n\t'}': tokenTypes.RIGHT_BRACE,\n\t'[': tokenTypes.LEFT_BRACKET,\n\t']': tokenTypes.RIGHT_BRACKET,\n\t':': tokenTypes.COLON,\n\t',': tokenTypes.COMMA\n};\n\nconst keywordTokensMap = { // Lexeme: Token config\n\t'true': { type: tokenTypes.TRUE, value: true },\n\t'false': { type: tokenTypes.FALSE, value: false },\n\t'null': { type: tokenTypes.NULL, value: null }\n};\n\nconst stringStates = {\n\t_START_: 0,\n\tSTART_QUOTE_OR_CHAR: 1,\n\tESCAPE: 2\n};\n\nconst escapes = {\n\t'\"': 0,\t\t// Quotation mask\n\t'\\\\': 1,\t// Reverse solidus\n\t'/': 2,\t\t// Solidus\n\t'b': 3,\t\t// Backspace\n\t'f': 4,\t\t// Form feed\n\t'n': 5,\t\t// New line\n\t'r': 6,\t\t// Carriage return\n\t't': 7,\t\t// Horizontal tab\n\t'u': 8\t\t// 4 hexadecimal digits\n};\n\nconst numberStates = {\n\t_START_: 0,\n\tMINUS: 1,\n\tZERO: 2,\n\tDIGIT: 3,\n\tPOINT: 4,\n\tDIGIT_FRACTION: 5,\n\tEXP: 6,\n\tEXP_DIGIT_OR_SIGN: 7\n};\n\n// HELPERS\n\nfunction isDigit1to9(char) {\n\treturn char >= '1' && char <= '9';\n}\n\nfunction isDigit(char) {\n\treturn char >= '0' && char <= '9';\n}\n\nfunction isHex(char) {\n\treturn (\n\t\tisDigit(char)\n\t\t|| (char >= 'a' && char <= 'f')\n\t\t|| (char >= 'A' && char <= 'F')\n\t);\n}\n\nfunction isExp(char) {\n\treturn char === 'e' || char === 'E';\n}\n\n// PARSERS\n\nfunction parseWhitespace(input, index, line, column) {\n\tvar value = \"\";\n\n  while (true) {\n    var char = input.charAt(index);\n  \tif (char === '\\r') { // CR (Unix)\n  \t\tindex ++;\n  \t\tline ++;\n  \t\tcolumn = 1;\n  \t\tvalue += char;\n  \t\tif (input.charAt(index) === '\\n') { // CRLF (Windows)\n  \t\t\tindex ++;\n        value += '\\n';\n  \t\t}\n  \t} else if (char === '\\n') { // LF (MacOS)\n  \t\tindex ++;\n  \t\tline ++;\n  \t\tcolumn = 1;\n      value += char;\n  \t} else if (char === '\\t' || char === ' ') {\n  \t\tindex ++;\n  \t\tcolumn ++;\n      value += char;\n  \t} else {\n  \t\tbreak;\n  \t}\n  }\n  if (value.length == 0)\n    return null;\n\n\treturn {\n\t\tindex,\n\t\tline,\n\t\tcolumn,\n\t\ttype: tokenTypes.WHITESPACE,\n\t\tvalue: value\n\t};\n}\n\nfunction parseComment(input, index, line, column) {\n  const str = input.substring(index, index + 2);\n  const startIndex = index;\n  \n  if (str === \"/*\") {\n    for (index += 2; index < input.length; index++) {\n      var char = input[index];\n      if (char === '*' && input[index + 1] === '/') {\n        index += 2;\n        column += 2;\n        break;\n      } else if (char === '\\r') { // CR (Unix)\n        index ++;\n        line ++;\n        column = 1;\n        if (input.charAt(index) === '\\n') { // CRLF (Windows)\n          index ++;\n        }\n      } else if (char === '\\n') { // LF (MacOS)\n        index ++;\n        line ++;\n        column = 1;\n      } else\n        column++;\n    }\n    return {\n      index,\n      line,\n      column,\n      type: tokenTypes.COMMENT,\n      value: input.substring(startIndex, index)\n    };\n    \n  } else if (str === \"//\") {\n    for (index += 2; index < input.length; index++) {\n      var char = input[index];\n      if (char === '\\r') { // CR (Unix)\n        index ++;\n        line ++;\n        column = 1;\n        if (input.charAt(index) === '\\n') { // CRLF (Windows)\n          index ++;\n        }\n        break;\n      } else if (char === '\\n') { // LF (MacOS)\n        index ++;\n        line ++;\n        column = 1;\n        break;\n      }\n    }\n    \n    return {\n      index,\n      line,\n      column,\n      type: tokenTypes.COMMENT,\n      value: input.substring(startIndex, index)\n    };\n  }\n  \n  return null;\n}\n\nfunction parseChar(input, index, line, column) {\n\tconst char = input.charAt(index);\n\n\tif (char in punctuatorTokensMap) {\n\t\treturn {\n\t\t\ttype: punctuatorTokensMap[char],\n\t\t\tline,\n\t\t\tcolumn: column + 1,\n\t\t\tindex: index + 1,\n\t\t\tvalue: char\n\t\t};\n\t}\n\n\treturn null;\n}\n\nfunction parseKeyword(input, index, line, column) {\n\tfor (const name in keywordTokensMap) {\n\t\tif (keywordTokensMap.hasOwnProperty(name) && input.substr(index, name.length) === name) {\n\t\t\tconst {type, value} = keywordTokensMap[name];\n\n\t\t\treturn {\n\t\t\t\ttype,\n\t\t\t\tline,\n\t\t\t\tcolumn: column + name.length,\n\t\t\t\tindex: index + name.length,\n\t\t\t\tvalue\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\nfunction parseString(input, index, line, column, settings) {\n\tconst startIndex = index;\n\tlet buffer = '';\n\tlet state = stringStates._START_;\n\n\twhile (index < input.length) {\n\t\tconst char = input.charAt(index);\n\n\t\tswitch (state) {\n\t\t\tcase stringStates._START_: {\n\t\t\t\tif (char === '\"') {\n\t\t\t\t\tstate = stringStates.START_QUOTE_OR_CHAR;\n\t\t\t\t\tindex ++;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase stringStates.START_QUOTE_OR_CHAR: {\n\t\t\t\tif (char === '\\\\') {\n\t\t\t\t\tstate = stringStates.ESCAPE;\n\t\t\t\t\tbuffer += char;\n\t\t\t\t\tindex ++;\n\t\t\t\t} else if (char === '\"') {\n\t\t\t\t\tindex ++;\n\t\t\t\t\tvar result = {\n\t\t\t\t\t\ttype: tokenTypes.STRING,\n\t\t\t\t\t\tline,\n\t\t\t\t\t\tcolumn: column + index - startIndex,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\tvalue: buffer\n\t\t\t\t\t};\n\t\t\t\t\tif (settings.verbose)\n\t\t\t\t\t  result.rawValue = input.substring(startIndex, index);\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t\tindex ++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase stringStates.ESCAPE: {\n\t\t\t\tif (char in escapes) {\n\t\t\t\t\tbuffer += char;\n\t\t\t\t\tindex ++;\n\t\t\t\t\tif (char === 'u') {\n\t\t\t\t\t\tfor (let i = 0; i < 4; i ++) {\n\t\t\t\t\t\t\tconst curChar = input.charAt(index);\n\t\t\t\t\t\t\tif (curChar && isHex(curChar)) {\n\t\t\t\t\t\t\t\tbuffer += curChar;\n\t\t\t\t\t\t\t\tindex ++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstate = stringStates.START_QUOTE_OR_CHAR;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction parseNumber(input, index, line, column) {\n\tconst startIndex = index;\n\tlet passedValueIndex = index;\n\tlet state = numberStates._START_;\n\n\titerator: while (index < input.length) {\n\t\tconst char = input.charAt(index);\n\n\t\tswitch (state) {\n\t\t\tcase numberStates._START_: {\n\t\t\t\tif (char === '-') {\n\t\t\t\t\tstate = numberStates.MINUS;\n\t\t\t\t} else if (char === '0') {\n\t\t\t\t\tpassedValueIndex = index + 1;\n\t\t\t\t\tstate = numberStates.ZERO;\n\t\t\t\t} else if (isDigit1to9(char)) {\n\t\t\t\t\tpassedValueIndex = index + 1;\n\t\t\t\t\tstate = numberStates.DIGIT;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase numberStates.MINUS: {\n\t\t\t\tif (char === '0') {\n\t\t\t\t\tpassedValueIndex = index + 1;\n\t\t\t\t\tstate = numberStates.ZERO;\n\t\t\t\t} else if (isDigit1to9(char)) {\n\t\t\t\t\tpassedValueIndex = index + 1;\n\t\t\t\t\tstate = numberStates.DIGIT;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase numberStates.ZERO: {\n\t\t\t\tif (char === '.') {\n\t\t\t\t\tstate = numberStates.POINT;\n\t\t\t\t} else if (isExp(char)) {\n\t\t\t\t\tstate = numberStates.EXP;\n\t\t\t\t} else {\n\t\t\t\t\tbreak iterator;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase numberStates.DIGIT: {\n\t\t\t\tif (isDigit(char)) {\n\t\t\t\t\tpassedValueIndex = index + 1;\n\t\t\t\t} else if (char === '.') {\n\t\t\t\t\tstate = numberStates.POINT;\n\t\t\t\t} else if (isExp(char)) {\n\t\t\t\t\tstate = numberStates.EXP;\n\t\t\t\t} else {\n\t\t\t\t\tbreak iterator;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase numberStates.POINT: {\n\t\t\t\tif (isDigit(char)) {\n\t\t\t\t\tpassedValueIndex = index + 1;\n\t\t\t\t\tstate = numberStates.DIGIT_FRACTION;\n\t\t\t\t} else {\n\t\t\t\t\tbreak iterator;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase numberStates.DIGIT_FRACTION: {\n\t\t\t\tif (isDigit(char)) {\n\t\t\t\t\tpassedValueIndex = index + 1;\n\t\t\t\t} else if (isExp(char)) {\n\t\t\t\t\tstate = numberStates.EXP;\n\t\t\t\t} else {\n\t\t\t\t\tbreak iterator;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase numberStates.EXP: {\n\t\t\t\tif (char === '+' || char === '-') {\n\t\t\t\t\tstate = numberStates.EXP_DIGIT_OR_SIGN;\n\t\t\t\t} else if (isDigit(char)) {\n\t\t\t\t\tpassedValueIndex = index + 1;\n\t\t\t\t\tstate = numberStates.EXP_DIGIT_OR_SIGN;\n\t\t\t\t} else {\n\t\t\t\t\tbreak iterator;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase numberStates.EXP_DIGIT_OR_SIGN: {\n\t\t\t\tif (isDigit(char)) {\n\t\t\t\t\tpassedValueIndex = index + 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak iterator;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tindex ++;\n\t}\n\n\tif (passedValueIndex > 0) {\n\t\treturn {\n\t\t\ttype: tokenTypes.NUMBER,\n\t\t\tline,\n\t\t\tcolumn: column + passedValueIndex - startIndex,\n\t\t\tindex: passedValueIndex,\n\t\t\tvalue: parseFloat(input.substring(startIndex, passedValueIndex))\n\t\t};\n\t}\n\n\treturn null;\n}\n\nexport class Tokenizer {\n  constructor(input, settings) {\n    this.input = input;\n    this.settings = settings||{};\n    this.tokens = null;\n    this.tokenIndex = -1;\n  }\n  \n  token() {\n    if (this.tokens === null)\n      throw new Error(\"No tokens to return (have you called tokenize?)\");\n    if (this.tokenIndex >= this.tokens.length)\n      throw new Error(\"No more tokens available\");\n    if (this.tokenIndex < 0)\n    \treturn this.next();\n    return this.tokens[this.tokenIndex];\n  }\n  \n  hasMore() {\n    if (this.tokens === null)\n      throw new Error(\"No tokens to return (have you called tokenize?)\");\n    \n    if (this.settings.returnWhitespace) {\n      return this.tokenIndex < this.tokens.length;\n    }\n    \n    var tokenIndex = this.tokenIndex;\n    if (tokenIndex < 0)\n    \ttokenIndex = 0;\n    for (; tokenIndex < this.tokens.length; tokenIndex++) {\n      var token = this.tokens[tokenIndex];\n      if (token.type != tokenTypes.COMMENT && token.type != tokenTypes.WHITESPACE)\n        return true;\n    }\n    return false;\n  }\n  \n  next() {\n    if (this.tokens === null)\n      throw new Error(\"No tokens to return (have you called tokenize?)\");\n    if (this.tokenIndex >= this.tokens.length)\n      throw new Error(\"No more tokens to get\");\n    \n    if (this.settings.returnWhitespace) {\n      if (this.tokenIndex < this.tokens.length)\n        return this.tokens[++this.tokenIndex];\n      \n    } else {\n      for (++this.tokenIndex; this.tokenIndex < this.tokens.length; this.tokenIndex++) {\n        var token = this.tokens[this.tokenIndex];\n        if (token.type != tokenTypes.COMMENT && token.type != tokenTypes.WHITESPACE)\n          return token;\n      }\n    }\n    \n    return null;\n  }\n  \n  tokenize() {\n    let line = 1;\n    let column = 1;\n    let index = 0;\n    const tokens = this.tokens = [];\n    var input = this.input;\n\n    while (index < input.length) {\n      const args = [input, index, line, column, this.settings];\n\n      const matched = (\n           parseWhitespace(...args)\n        || parseComment(...args)\n        || parseChar(...args)\n        || parseKeyword(...args)\n        || parseString(...args)\n        || parseNumber(...args)\n      );\n\n      if (matched) {\n        const token = {\n          type: matched.type,\n          value: matched.value,\n          loc: location(\n            line,\n            column,\n            index,\n            matched.line,\n            matched.column,\n            matched.index,\n            this.settings.source\n          )\n        };\n        if (matched.rawValue)\n          token.rawValue = matched.rawValue;\n\n        tokens.push(token);\n        index = matched.index;\n        line = matched.line;\n        column = matched.column;\n\n      } else {\n        error(\n          tokenizeErrorTypes.cannotTokenizeSymbol(input.charAt(index), line, column),\n          input,\n          line,\n          column\n        );\n\n      }\n    }\n\n    return tokens;\n  }\n}\n"]}